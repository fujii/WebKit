<!DOCTYPE html>
<html>
<head>
<title>WebKit Performance Test Results</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/flot/0.8.3/jquery.flot.min.js" integrity="sha512-eO1AKNIv7KSFl5n81oHCKnYLMi8UV4wWD1TcLYKNTssoECDuiGhoRsQkdiZkl8VUjoms2SeJY7zTSw5noGSqbQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tablesorter/2.2.2/js/jquery.tablesorter.min.js" integrity="sha512-hHIcNPKAJYB0NTpgnuAlW0+4rIhNCLmB1Xh7UyPfhPe1hcVGZcb8Woi4dXAS4s5JFuhtfuNZxV/lRWQVVzuoSg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
/*
 * Copyright (C) 2012, 2013 Apple Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

var Statistics = new (function () {

    this.max = function (values) {
        return Math.max.apply(Math, values);
    }

    this.min = function (values) {
        return Math.min.apply(Math, values);
    }

    this.sum = function (values) {
        return values.reduce(function (a, b) { return a + b; }, 0);
    }

    this.squareSum = function (values) {
        return values.reduce(function (sum, value) { return sum + value * value;}, 0);
    }

    // With sum and sum of squares, we can compute the sample standard deviation in O(1).
    // See https://rniwa.com/2012-11-10/sample-standard-deviation-in-terms-of-sum-and-square-sum-of-samples/
    this.sampleStandardDeviation = function (numberOfSamples, sum, squareSum) {
        if (numberOfSamples < 2)
            return 0;
        return Math.sqrt(squareSum / (numberOfSamples - 1)
            - sum * sum / (numberOfSamples - 1) / numberOfSamples);
    }

    this.supportedConfidenceLevels = function () {
        var supportedLevels = [];
        for (var quantile in tDistributionInverseCDF)
            supportedLevels.push((1 - (1 - quantile) * 2).toFixed(2));
        return supportedLevels;
    }

    // Computes the delta d s.t. (mean - d, mean + d) is the confidence interval with the specified confidence level in O(1).
    this.confidenceIntervalDelta = function (confidenceLevel, numberOfSamples, sum, squareSum) {
        var probability = (1 - (1 - confidenceLevel) / 2);
        if (!(probability in tDistributionInverseCDF)) {
            throw 'We only support ' + this.supportedConfidenceLevels().map(
                function (level) { return level * 100 + '%'; } ).join(', ') + ' confidence intervals.';
        }
        if (numberOfSamples - 2 < 0)
            return NaN;

        var cdfForProbability = tDistributionInverseCDF[probability];
        var degreesOfFreedom = numberOfSamples - 1;
        if (degreesOfFreedom > cdfForProbability.length)
            throw 'We only support up to ' + deltas.length + ' degrees of freedom';

        // tDistributionQuantile(degreesOfFreedom, confidenceLevel) * sampleStandardDeviation / sqrt(numberOfSamples) * S/sqrt(numberOfSamples)
        var quantile = cdfForProbability[degreesOfFreedom - 1]; // The first entry is for the one degree of freedom.
        return quantile * this.sampleStandardDeviation(numberOfSamples, sum, squareSum) / Math.sqrt(numberOfSamples);
    }

    this.confidenceInterval = function (values, probability) {
        var sum = this.sum(values);
        var mean = sum / values.length;
        var delta = this.confidenceIntervalDelta(probability || 0.95, values.length, sum, this.squareSum(values));
        return [mean - delta, mean + delta];
    }

    // See http://en.wikipedia.org/wiki/Student's_t-distribution#Table_of_selected_values
    // This table contains one sided (a.k.a. tail) values.
    var tDistributionInverseCDF = {
        0.9: [
            3.077684, 1.885618, 1.637744, 1.533206, 1.475884, 1.439756, 1.414924, 1.396815, 1.383029, 1.372184,
            1.363430, 1.356217, 1.350171, 1.345030, 1.340606, 1.336757, 1.333379, 1.330391, 1.327728, 1.325341,
            1.323188, 1.321237, 1.319460, 1.317836, 1.316345, 1.314972, 1.313703, 1.312527, 1.311434, 1.310415,
            1.309464, 1.308573, 1.307737, 1.306952, 1.306212, 1.305514, 1.304854, 1.304230, 1.303639, 1.303077,
            1.302543, 1.302035, 1.301552, 1.301090, 1.300649, 1.300228, 1.299825, 1.299439, 1.299069, 1.298714,

            1.298373, 1.298045, 1.297730, 1.297426, 1.297134, 1.296853, 1.296581, 1.296319, 1.296066, 1.295821,
            1.295585, 1.295356, 1.295134, 1.294920, 1.294712, 1.294511, 1.294315, 1.294126, 1.293942, 1.293763,
            1.293589, 1.293421, 1.293256, 1.293097, 1.292941, 1.292790, 1.292643, 1.292500, 1.292360, 1.292224,
            1.292091, 1.291961, 1.291835, 1.291711, 1.291591, 1.291473, 1.291358, 1.291246, 1.291136, 1.291029,
            1.290924, 1.290821, 1.290721, 1.290623, 1.290527, 1.290432, 1.290340, 1.290250, 1.290161, 1.290075],
        0.95: [
            6.313752, 2.919986, 2.353363, 2.131847, 2.015048, 1.943180, 1.894579, 1.859548, 1.833113, 1.812461,
            1.795885, 1.782288, 1.770933, 1.761310, 1.753050, 1.745884, 1.739607, 1.734064, 1.729133, 1.724718,
            1.720743, 1.717144, 1.713872, 1.710882, 1.708141, 1.705618, 1.703288, 1.701131, 1.699127, 1.697261,
            1.695519, 1.693889, 1.692360, 1.690924, 1.689572, 1.688298, 1.687094, 1.685954, 1.684875, 1.683851,
            1.682878, 1.681952, 1.681071, 1.680230, 1.679427, 1.678660, 1.677927, 1.677224, 1.676551, 1.675905,

            1.675285, 1.674689, 1.674116, 1.673565, 1.673034, 1.672522, 1.672029, 1.671553, 1.671093, 1.670649,
            1.670219, 1.669804, 1.669402, 1.669013, 1.668636, 1.668271, 1.667916, 1.667572, 1.667239, 1.666914,
            1.666600, 1.666294, 1.665996, 1.665707, 1.665425, 1.665151, 1.664885, 1.664625, 1.664371, 1.664125,
            1.663884, 1.663649, 1.663420, 1.663197, 1.662978, 1.662765, 1.662557, 1.662354, 1.662155, 1.661961,
            1.661771, 1.661585, 1.661404, 1.661226, 1.661052, 1.660881, 1.660715, 1.660551, 1.660391, 1.660234],
        0.975: [
            12.706205, 4.302653, 3.182446, 2.776445, 2.570582, 2.446912, 2.364624, 2.306004, 2.262157, 2.228139,
            2.200985, 2.178813, 2.160369, 2.144787, 2.131450, 2.119905, 2.109816, 2.100922, 2.093024, 2.085963,
            2.079614, 2.073873, 2.068658, 2.063899, 2.059539, 2.055529, 2.051831, 2.048407, 2.045230, 2.042272,
            2.039513, 2.036933, 2.034515, 2.032245, 2.030108, 2.028094, 2.026192, 2.024394, 2.022691, 2.021075,
            2.019541, 2.018082, 2.016692, 2.015368, 2.014103, 2.012896, 2.011741, 2.010635, 2.009575, 2.008559,

            2.007584, 2.006647, 2.005746, 2.004879, 2.004045, 2.003241, 2.002465, 2.001717, 2.000995, 2.000298,
            1.999624, 1.998972, 1.998341, 1.997730, 1.997138, 1.996564, 1.996008, 1.995469, 1.994945, 1.994437,
            1.993943, 1.993464, 1.992997, 1.992543, 1.992102, 1.991673, 1.991254, 1.990847, 1.990450, 1.990063,
            1.989686, 1.989319, 1.988960, 1.988610, 1.988268, 1.987934, 1.987608, 1.987290, 1.986979, 1.986675,
            1.986377, 1.986086, 1.985802, 1.985523, 1.985251, 1.984984, 1.984723, 1.984467, 1.984217, 1.983972],
        0.99: [
            31.820516, 6.964557, 4.540703, 3.746947, 3.364930, 3.142668, 2.997952, 2.896459, 2.821438, 2.763769,
            2.718079, 2.680998, 2.650309, 2.624494, 2.602480, 2.583487, 2.566934, 2.552380, 2.539483, 2.527977,
            2.517648, 2.508325, 2.499867, 2.492159, 2.485107, 2.478630, 2.472660, 2.467140, 2.462021, 2.457262,
            2.452824, 2.448678, 2.444794, 2.441150, 2.437723, 2.434494, 2.431447, 2.428568, 2.425841, 2.423257,
            2.420803, 2.418470, 2.416250, 2.414134, 2.412116, 2.410188, 2.408345, 2.406581, 2.404892, 2.403272,

            2.401718, 2.400225, 2.398790, 2.397410, 2.396081, 2.394801, 2.393568, 2.392377, 2.391229, 2.390119,
            2.389047, 2.388011, 2.387008, 2.386037, 2.385097, 2.384186, 2.383302, 2.382446, 2.381615, 2.380807,
            2.380024, 2.379262, 2.378522, 2.377802, 2.377102, 2.376420, 2.375757, 2.375111, 2.374482, 2.373868,
            2.373270, 2.372687, 2.372119, 2.371564, 2.371022, 2.370493, 2.369977, 2.369472, 2.368979, 2.368497,
            2.368026, 2.367566, 2.367115, 2.366674, 2.366243, 2.365821, 2.365407, 2.365002, 2.364606, 2.364217]
    };

})();

if (typeof module != 'undefined') {
    for (var key in Statistics)
        module.exports[key] = Statistics[key];
}

</script>
<style type="text/css">

section {
    background: white;
    padding: 10px;
    position: relative;
}

.time-plots {
    padding-left: 25px;
}

.time-plots > div {
    display: inline-block;
    width: 90px;
    height: 40px;
    margin-right: 10px;
}

section h1 {
    text-align: center;
    font-size: 1em;
}

section .tooltip {
    position: absolute;
    text-align: center;
    background: #ffcc66;
    border-radius: 5px;
    padding: 0px 5px;
}

body {
    padding: 0px;
    margin: 0px;
    font-family: sans-serif;
}

table {
    background: white;
    width: 100%;
}

table, td, th {
    border-collapse: collapse;
    padding: 5px;
}

tr.even {
    background: #f6f6f6;
}

table td {
    position: relative;
    font-family: monospace;
}

th, td {
    cursor: pointer;
    cursor: hand;
}

th {
    background: #e6eeee;
    background: -webkit-gradient(linear, left top, left bottom, from(rgb(244, 244, 244)), to(rgb(217, 217, 217)));
    border: 1px solid #ccc;
}

th:after {
    content: ' \25B8';
}

th.headerSortUp:after {
    content: ' \25BE';
}

th.headerSortDown:after {
    content: ' \25B4';
}

td.comparison, td.result {
    text-align: right;
}

td.better {
    color: #6c6;
}

td.worse {
    color: #c66;
}

td.missing {
    text-align: center;
}

.checkbox {
    display: inline-block;
    background: #eee;
    background: -webkit-gradient(linear, left bottom, left top, from(rgb(220, 220, 220)), to(rgb(200, 200, 200)));
    border: inset 1px #ddd;
    border-radius: 5px;
    margin: 10px;
    font-size: small;
    cursor: pointer;
    cursor: hand;
    -webkit-user-select: none;
    font-weight: bold;
}

.checkbox span {
    display: inline-block;
    line-height: 100%;
    padding: 5px 8px;
    border: outset 1px transparent;
}

.checkbox .checked {
    background: #e6eeee;
    background: -webkit-gradient(linear, left top, left bottom, from(rgb(255, 255, 255)), to(rgb(235, 235, 235)));
    border: outset 1px #eee;
    border-radius: 5px;
}

</style>
</head>
<body>
<div style="padding: 0 10px;">
Result <span id="time-memory" class="checkbox"><span class="checked">Time</span><span>Memory</span></span>
Reference <span id="reference" class="checkbox"></span>
<span title="Confidence Interval Delta">CI&#916;</span> <span id="confidenceIntervalDelta" class="checkbox"><span class="checked">Show</span><span>Hide</span></span>
</div>
<table id="container"></table>
<script>
function TestResult(metric, values, associatedRun) {
    if (values[0] instanceof Array) {
        var flattenedValues = [];
        for (var i = 0; i < values.length; i++)
            flattenedValues = flattenedValues.concat(values[i]);
        values = flattenedValues;
    }

    this.test = function () { return metric; }
    this.values = function () { return values.map(function (value) { return metric.scalingFactor() * value; }); }
    this.unscaledMean = function () { return Statistics.sum(values) / values.length; }
    this.mean = function () { return metric.scalingFactor() * this.unscaledMean(); }
    this.min = function () { return metric.scalingFactor() * Statistics.min(values); }
    this.max = function () { return metric.scalingFactor() * Statistics.max(values); }
    this.confidenceIntervalDelta = function () {
        return metric.scalingFactor() * Statistics.confidenceIntervalDelta(0.95, values.length,
            Statistics.sum(values), Statistics.squareSum(values));
    }
    this.confidenceIntervalDeltaRatio = function () { return this.confidenceIntervalDelta() / this.mean(); }
    this.percentDifference = function(other) { return (other.unscaledMean() - this.unscaledMean()) / this.unscaledMean(); }
    this.isStatisticallySignificant = function (other) {
        var diff = Math.abs(other.mean() - this.mean());
        return diff > this.confidenceIntervalDelta() && diff > other.confidenceIntervalDelta();
    }
    this.run = function () { return associatedRun; }
}

function TestRun(entry) {
    this.description = function () { return entry['description']; }
    this.webkitRevision = function () { return entry['revisions']['WebKit']['revision']; }
    this.label = function () {
        var label = 'r' + this.webkitRevision();
        if (this.description())
            label += ' &dash; ' + this.description();
        return label;
    }
}

function PerfTestMetric(name, metric) {
    var testResults = [];
    var cachedUnit = null;
    var cachedScalingFactor = null;
    var unit = {'FrameRate': 'fps', 'Runs': 'runs/s', 'Score': 'pt', 'Time': 'ms', 'Malloc': 'bytes', 'JSHeap': 'bytes'}[metric];

    // We can't do this in TestResult because all results for each test need to share the same unit and the same scaling factor.
    function computeScalingFactorIfNeeded() {
        // FIXME: We shouldn't be adjusting units on every test result.
        // We can only do this on the first test.
        if (!testResults.length || cachedUnit)
            return;

        var mean = testResults[0].unscaledMean(); // FIXME: We should look at all values.
        var kilo = unit == 'bytes' ? 1024 : 1000;
        if (mean > 10 * kilo * kilo && unit != 'ms') {
            cachedScalingFactor = 1 / kilo / kilo;
            cachedUnit = 'M ' + unit;
        } else if (mean > 10 * kilo) {
            cachedScalingFactor = 1 / kilo;
            cachedUnit = unit == 'ms' ? 's' : ('K ' + unit);
        } else {
            cachedScalingFactor = 1;
            cachedUnit = unit;
        }
    }

    this.name = function () { return name + ':' + metric; }
    this.isMemoryTest = function () { return metric == 'JSHeap' || metric == 'Malloc'; }
    this.addResult = function (newResult) {
        testResults.push(newResult);
        cachedUnit = null;
        cachedScalingFactor = null;
    }
    this.results = function () { return testResults; }
    this.scalingFactor = function() {
        computeScalingFactorIfNeeded();
        return cachedScalingFactor;
    }
    this.unit = function () {
        computeScalingFactorIfNeeded();
        return cachedUnit;
    }
    this.smallerIsBetter = function () { return unit == 'ms' || unit == 'bytes'; }
}

var plotColor = 'rgb(230,50,50)';
var subpointsPlotOptions = {
    lines: {show:true, lineWidth: 0},
    color: plotColor,
    points: {show: true, radius: 1},
    bars: {show: false}};

var mainPlotOptions = {
    xaxis: {
        min: -0.5,
        tickSize: 1,
    },
    crosshair: { mode: 'y' },
    series: { shadowSize: 0 },
    bars: {show: true, align: 'center', barWidth: 0.5},
    lines: { show: false },
    points: { show: true },
    grid: {
        borderWidth: 1,
        borderColor: '#ccc',
        backgroundColor: '#fff',
        hoverable: true,
        autoHighlight: false,
    }
};

var timePlotOptions = {
    yaxis: { show: false },
    xaxis: { show: false },
    lines: { show: true },
    grid: { borderWidth: 1, borderColor: '#ccc' },
    colors: [ plotColor ]
};

function createPlot(container, test) {
    var section = $('<section><div class="plot"></div><div class="time-plots"></div>'
        + '<span class="tooltip"></span></section>');
    section.children('.plot').css({'width': (100 * test.results().length + 25) + 'px', 'height': '300px'});
    $(container).append(section);

    var plotContainer = section.children('.plot');
    var minIsZero = true;
    attachPlot(test, plotContainer, minIsZero);

    attachTimePlots(test, section.children('.time-plots'));

    var tooltip = section.children('.tooltip');
    plotContainer.bind('plothover', function (event, position, item) {
        if (item) {
            var postfix = item.series.id ? ' (' + item.series.id + ')' : '';
            tooltip.html(item.datapoint[1].toPrecision(4) + postfix);
            var sectionOffset = $(section).offset();
            tooltip.css({left: item.pageX - sectionOffset.left - tooltip.outerWidth() / 2, top: item.pageY - sectionOffset.top + 10});
            tooltip.fadeIn(200);
        } else
            tooltip.hide();
    });
    plotContainer.mouseout(function () {
        tooltip.hide();
    });
    plotContainer.click(function (event) {
        event.preventDefault();
        minIsZero = !minIsZero;
        attachPlot(test, plotContainer, minIsZero);
    });

    return section;
}

function attachTimePlots(test, container) {
    var results = test.results();
    var attachedPlot = false;
    for (var i = 0; i < results.length; i++) {
        container.append('<div></div>');
        var values = results[i].values();
        if (!values)
            continue;
        attachedPlot = true;

        $.plot(container.children().last(), [values.map(function (value, index) { return [index, value]; })],
            $.extend(true, {}, timePlotOptions, {yaxis: {min: Math.min.apply(Math, values) * 0.9, max: Math.max.apply(Math, values) * 1.1},
                xaxis: {min: -0.5, max: values.length - 0.5}}));
    }
    if (!attachedPlot)
        container.children().remove();
}

function attachPlot(test, plotContainer, minIsZero) {
    var results = test.results();

    var values = results.reduce(function (values, result, index) {
        var newValues = result.values();
        return newValues ? values.concat(newValues.map(function (value) { return [index, value]; })) : values;
    }, []);

    var plotData = [$.extend(true, {}, subpointsPlotOptions, {data: values})];
    plotData.push({id: '&mu;', data: results.map(function (result, index) { return [index, result.mean()]; }), color: plotColor});

    var overallMax = Statistics.max(results.map(function (result, index) { return result.max(); }));
    var overallMin = Statistics.min(results.map(function (result, index) { return result.min(); }));
    var margin = (overallMax - overallMin) * 0.1;
    var currentPlotOptions = $.extend(true, {}, mainPlotOptions, {yaxis: {
        min: minIsZero ? 0 : overallMin - margin,
        max: minIsZero ? overallMax * 1.1 : overallMax + margin}});

    currentPlotOptions.xaxis.max = results.length - 0.5;
    currentPlotOptions.xaxis.ticks = results.map(function (result, index) { return [index, result.run().label()]; });

    $.plot(plotContainer, plotData, currentPlotOptions);
}

function toFixedWidthPrecision(value) {
    var decimal = value.toFixed(2);
    return decimal;
}

function formatPercentage(fraction) {
    var percentage = fraction * 100;
    return (fraction * 100).toFixed(2) + '%';
}

function createTable(tests, runs, shouldIgnoreMemory, referenceIndex, hideConfidenceIntervalDelta) {
    $('#container').html('<thead><tr><th>Test</th><th>Unit</th>' + runs.map(function (run, index) {
        var colspan = 2;
        if (index != referenceIndex)
            colspan = 3;
        if (hideConfidenceIntervalDelta)
            colspan--;
        return '<th colspan="' + colspan + '" class="{sorter: \'comparison\'}">' + run.label() + '</th>';
    }).reduce(function (markup, cell) { return markup + cell; }, '') + '</tr></head><tbody></tbody>');

    var testNames = [];
    for (testName in tests)
        testNames.push(testName);

    testNames.sort().map(function (testName) {
        var test = tests[testName];
        if (test.isMemoryTest() != shouldIgnoreMemory)
            createTableRow(runs, test, referenceIndex, hideConfidenceIntervalDelta);
    });

    $('#container').tablesorter({widgets: ['zebra']});
}

function linearRegression(points) {
    // Implement http://www.easycalculation.com/statistics/learn-correlation.php.
    // x = magnitude
    // y = iterations
    var sumX = 0;
    var sumY = 0;
    var sumXSquared = 0;
    var sumYSquared = 0;
    var sumXTimesY = 0;

    for (var i = 0; i < points.length; i++) {
        var x = i;
        var y = points[i];
        sumX += x;
        sumY += y;
        sumXSquared += x * x;
        sumYSquared += y * y;
        sumXTimesY += x * y;
    }

    var r = (points.length * sumXTimesY - sumX * sumY) /
        Math.sqrt((points.length * sumXSquared - sumX * sumX) *
                  (points.length * sumYSquared - sumY * sumY));

    if (isNaN(r) || r == Math.Infinity)
        r = 0;

    var slope = (points.length * sumXTimesY - sumX * sumY) / (points.length * sumXSquared - sumX * sumX);
    var intercept = sumY / points.length - slope * sumX / points.length;
    return {slope: slope, intercept: intercept, rSquared: r * r};
}

var warningSign = '<svg viewBox="0 0 100 100" style="width: 18px; height: 18px; vertical-align: bottom;" version="1.1">'
    + '<polygon fill="red" points="50,10 90,80 10,80 50,10" stroke="red" stroke-width="10" stroke-linejoin="round" />'
    + '<polygon fill="white" points="47,30 48,29, 50, 28.7, 52,29 53,30 50,60" stroke="white" stroke-width="10" stroke-linejoin="round" />'
    + '<circle cx="50" cy="73" r="6" fill="white" />'
    + '</svg>';

function createTableRow(runs, test, referenceIndex, hideConfidenceIntervalDelta) {
    var tableRow = $('<tr><td class="test">' + test.name() + '</td><td class="unit">' + test.unit() + '</td></tr>');

    function markupForRun(result, referenceResult) {
        var comparisonCell = '';
        var hiddenValue = '';
        var shouldCompare = result !== referenceResult;
        if (shouldCompare && referenceResult) {
            var percentDifference = referenceResult.percentDifference(result);
            var better = test.smallerIsBetter() ? percentDifference < 0 : percentDifference > 0;
            var comparison = '';
            var className = 'comparison';
            if (referenceResult.isStatisticallySignificant(result)) {
                comparison = formatPercentage(Math.abs(percentDifference)) + (better ? ' Better' : ' Worse&nbsp;');
                className += better ? ' better' : ' worse';
            }
            hiddenValue = '<span style="display: none">|' + comparison + '</span>';
            comparisonCell = '<td class="' + className + '">' + comparison + '</td>';
        } else if (shouldCompare)
            comparisonCell = '<td class="comparison"></td>';

        var values = result.values();
        var warning = '';
        var regressionAnalysis = '';
        if (values && values.length > 3) {
            regressionResult = linearRegression(values);
            regressionAnalysis = 'slope=' + toFixedWidthPrecision(regressionResult.slope)
                + ', R^2=' + toFixedWidthPrecision(regressionResult.rSquared);
            if (regressionResult.rSquared > 0.6 && Math.abs(regressionResult.slope) > 0.01) {
                warning = ' <span class="regression-warning" title="Detected a time dependency with ' + regressionAnalysis + '">' + warningSign + ' </span>';
            }
        }

        var statistics = '&sigma;=' + toFixedWidthPrecision(result.confidenceIntervalDelta()) + ', min=' + toFixedWidthPrecision(result.min())
            + ', max=' + toFixedWidthPrecision(result.max()) + '\n' + regressionAnalysis;

        var confidenceIntervalDeltaCell = '';
        if (!hideConfidenceIntervalDelta) {
            confidenceIntervalDeltaCell = '<td class="confidenceIntervalDelta" title="' + statistics + '">&plusmn; '
                + formatPercentage(result.confidenceIntervalDeltaRatio()) + warning + '</td>';
        }

        // Tablesorter doesn't know about the second cell so put the comparison in the invisible element.
        return '<td class="result" title="' + statistics + '">' + toFixedWidthPrecision(result.mean()) + hiddenValue
            + '</td>' + confidenceIntervalDeltaCell + comparisonCell;
    }

    function markupForMissingRun(isReference) {
        return '<td colspan="' + (isReference ? 2 : 3) + '" class="missing">Missing</td>';
    }

    var runIndex = 0;
    var results = test.results();
    var referenceResult = undefined;
    var resultIndexMap = {};
    for (var i = 0; i < results.length; i++) {
        while (runs[runIndex] !== results[i].run())
            runIndex++;
        if (runIndex == referenceIndex)
            referenceResult = results[i];
        resultIndexMap[runIndex] = i;
    }
    for (var i = 0; i < runs.length; i++) {
        var resultIndex = resultIndexMap[i];
        if (resultIndex == undefined)
            tableRow.append(markupForMissingRun(i == referenceIndex));
        else
            tableRow.append(markupForRun(results[resultIndex], referenceResult));
    }

    $('#container').children('tbody').last().append(tableRow);

    tableRow.click(function (event) {
        if (event.target != tableRow[0] && event.target.parentNode != tableRow[0])
            return;

        event.preventDefault();

        var firstCell = tableRow.children('td').first();
        if (firstCell.children('section').length) {
            firstCell.children('section').remove();
            tableRow.children('td').css({'padding-bottom': ''});
        } else {
            var plot = createPlot(firstCell, test);
            plot.css({'position': 'absolute', 'z-index': 2});
            var offset = tableRow.offset();
            offset.left += 1;
            offset.top += tableRow.outerHeight();
            plot.offset(offset);
            tableRow.children('td').css({'padding-bottom': plot.outerHeight() + 5});
        }

        return false;
    });
}

function init() {
    $.tablesorter.addParser({
        id: 'comparison',
        is: function(s) {
            return s.indexOf('|') >= 0;
        },
        format: function(s) {
            var parsed = parseFloat(s.substring(s.indexOf('|') + 1));
            return isNaN(parsed) ? 0 : parsed;
        },
        type: 'numeric',
    });

    var runs = [];
    var metrics = {};
    $.each(JSON.parse(document.getElementById('json').textContent), function (index, entry) {
        var run = new TestRun(entry);
        runs.push(run);

        function addTests(tests, parentFullName) {
            for (var testName in tests) {
                var fullTestName = parentFullName + '/' + testName;
                var rawMetrics = tests[testName].metrics;

                for (var metricName in rawMetrics) {
                    var fullMetricName = fullTestName + ':' + metricName;
                    var metric = metrics[fullMetricName];
                    if (!metric) {
                        metric = new PerfTestMetric(fullTestName, metricName);
                        metrics[fullMetricName] = metric;
                    }
                    metric.addResult(new TestResult(metric, rawMetrics[metricName].current, run));
                }

                if (tests[testName].tests)
                    addTests(tests[testName].tests, fullTestName);
            }
        }

        addTests(entry.tests, '');
    });

    var shouldIgnoreMemory= true;
    var referenceIndex = 0;
    var hideConfidenceIntervalDelta = false;

    createTable(metrics, runs, shouldIgnoreMemory, referenceIndex);

    $('#time-memory').bind('change', function (event, checkedElement) {
        shouldIgnoreMemory = checkedElement.textContent == 'Time';
        createTable(metrics, runs, shouldIgnoreMemory, referenceIndex, hideConfidenceIntervalDelta);
    });

    runs.map(function (run, index) {
        $('#reference').append('<span value="' + index + '"' + (index == referenceIndex ? ' class="checked"' : '') + '>' + run.label() + '</span>');
    })

    $('#reference').bind('change', function (event, checkedElement) {
        referenceIndex = parseInt(checkedElement.getAttribute('value'));
        createTable(metrics, runs, shouldIgnoreMemory, referenceIndex, hideConfidenceIntervalDelta);
    });

    $('#confidenceIntervalDelta').bind('change', function (event, checkedElement) {
        hideConfidenceIntervalDelta = checkedElement.textContent == 'Hide';
        createTable(metrics, runs, shouldIgnoreMemory, referenceIndex, hideConfidenceIntervalDelta);
    });

    $('.checkbox').each(function (index, checkbox) {
        $(checkbox).children('span').click(function (event) {
            if ($(this).hasClass('checked'))
                return;
            $(checkbox).children('span').removeClass('checked');
            $(this).addClass('checked');
            $(checkbox).trigger('change', $(this));
        });
    });
}
$(document).ready(init);
</script>
<script id="json" type="application/json">%PeformanceTestsResultsJSON%</script>
</body>
</html>
